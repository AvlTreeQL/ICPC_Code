/*************************************************************************
	> File Name: 蒜头君的新游戏.cpp
	> Author: heheql
	> Mail: 374655767@qq.com
	> Created Time: 2017年08月07日 星期一 01时30分35秒
mZ作空闲之余，蒜头君经常带着同事们做游戏，最近蒜头君发明了一个好玩的新游戏：
n 位同事围成一个圈，同事 A 手里拿着一个兔妮妮的娃娃。
蒜头君喊游戏开始，每位手里拿着娃娃的同事可以选择将娃娃传给左边或者右边的同学，
当蒜头君喊游戏结束时，停止传娃娃。此时手里拿着娃娃的同事即是败者。

玩了几轮之后，蒜头君想到一个问题：有多少种不同的方法，使得从同事 A 开始传娃娃，传了 m 次之后又回到了同事 A 手里。
两种方法，如果接娃娃的同事不同，或者接娃娃的顺序不同均视为不同的方法。
例如 1−>2−>3−>1 和 1−>3−>2−>1 是两种不同的方法。

输入格式

输入一行，输入两个整数 n,m(3≤n≤30,1≤m≤30)，表示一共有 n 位同事一起游戏，一共传 m 次娃娃。

输出格式

输出一行，输出一个整数，表示一共有多少种不同的传娃娃方法。

样例输入

3 3
样例输出

2
 ************************************************************************/

#include <iostream>
using namespace std;
int n, m, dp[50][50]={0};
int dfs(int i, int step){
    if(dp[i][step]) return dp[i][step];
    if(i == 0 && step == 0) return 1; 
    else if(step == 0) return 0;
    dp[i][step] += dfs((i+1)%n,step-1) + dfs((i-1)%n,step-1);
    return dp[i][step];
}
int main(){
	freopen("input.txt","r",stdin);
	ios::sync_with_stdio(false);
    cin >> n >> m;
    cout << dfs(0,m) << endl;    
	return 0;
}
