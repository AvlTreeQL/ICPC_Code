/*
【问题描述】从标准输入中输入两组正整数(每行不超过20个正整数，每组正整数中元素有可能重复)。
合并两组正整数，去掉在两组正整数中都出现的整数，并按从小到大顺序排序输出（
即两组正整数集;异或），输出时重复的元素只输出一次。
【输入形式】首先输入第一组正整数，以一个空格分隔各个正整数，以-1作为输入结束符；然后以同样的方式输入第二组正整数。
【输出形式】按从小到大顺序排序输出合并后的正整数集（去掉在两组正整数中都出现的正整数，以一个空格分隔各个整数）。
【样例输入】
5 1 4 32 872 9 5 32 872 -1
1 5 2 87 10 1 9 5 1 10 -1
【样例输出】2 4 10 32 87 872
【样例说明】第一组整数有9个，分别为：5 1 4 32 872 9 5 32 872。
			第二组整数有10个，分别为1 5 2 87 10 1 9 5 1 10。
			将第一组和第二组整数合并（去掉在两组整数中都出现的整数5、1和9），
			并按从小到大顺序排序后结果为2 4 10 32 87 872。重复的元素32、872和10都只输出一次。
【评分标准】该题要求输出两组整数的异或集，共有5个测试点，提交程序文件名为xor.c。
*/
#include<stdio.h>
#include<stdlib.h>
int cmp(const void*a,const void*b)
{
	return *(int *)a>*(int *)b?1:-1;
}
int main()
{
	int a[21],b[21],c[50],i=0,j,t=0,flag=0;
	do
	{
		scanf("%d",&a[i++]);
	}while(a[i-1]!=-1);
	i=0;
	do
	{
		scanf("%d",&b[i++]);
	}while(b[i-1]!=-1);
	for(i=0;a[i]!=-1;i++)
	{	flag=0;
		for(j=0;b[j]!=-1;j++)
		{
			if(b[j]==a[i]) flag=1;			
		
		}
		if(flag==0) c[t++]=a[i];
	}
	for(i=0;b[i]!=-1;i++)
	{	flag=0;
		for(j=0;a[j]!=-1;j++)
		{
			if(b[i]==a[j]) flag=1;			
		
		}
		if(flag==0) c[t++]=b[i];
	}
	c[t]='\0';
	qsort(c,t-1,sizeof(int),cmp);
	for(i=0;i<t-1;i++)
	{	printf("%d ",c[i]);
		while(c[i+1]!='\0'&&c[i]==c[i+1]) i++;
	}return 0;
}