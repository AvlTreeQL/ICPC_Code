/*

路径之谜

小明冒充X星球的骑士，进入了一个奇怪的城堡。
城堡里边什么都没有，只有方形石头铺成的地面。

假设城堡地面是 n x n 个方格。【如图1.png】所示。

按习俗，骑士要从西北角走到东南角。
可以横向或纵向移动，但不能斜着走，也不能跳跃。
每走到一个新方格，就要向正北方和正西方各射一箭。
（城堡的西墙和北墙内各有 n 个靶子）


同一个方格只允许经过一次。但不必走完所有的方格。

如果只给出靶子上箭的数目，你能推断出骑士的行走路线吗？

有时是可以的，比如图1.png中的例子。

本题的要求就是已知箭靶数字，求骑士的行走路径（测试数据保证路径唯一）

输入：
第一行一个整数N(0<N<20)，表示地面有 N x N 个方格
第二行N个整数，空格分开，表示北边的箭靶上的数字（自西向东）
第三行N个整数，空格分开，表示西边的箭靶上的数字（自北向南）

输出：
一行若干个整数，表示骑士路径。

为了方便表示，我们约定每个小格子用一个数字代表，从西北角开始编号: 0,1,2,3....
比如，图1.png中的方块编号为：

0  1  2  3
4  5  6  7
8  9  10 11
12 13 14 15


示例：
用户输入：
4
2 4 3 4
4 3 3 3

程序应该输出：
0 4 5 1 2 3 7 11 10 9 13 14 15


资源约定：
峰值内存消耗 < 256M
CPU消耗  < 1000ms

请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。

所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。

注意: main函数需要返回0
注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。
注意: 所有依赖的函数必须明确地在源文件中 #include <xxx>， 不能通过工程设置而省略常用头文件。

提交时，注意选择所期望的编译器类型。
0  1  2  3
4  5  6  7
8  9  10 11
12 13 14 15


示例：
用户输入：
4
2 4 3 4
4 3 3 3

程序应该输出：
0 4 5 1 2 3 7 11 10 9 13 14 15
*/
#include<bits/stdc++.h>
using namespace std;
int a[25][25];
bool visit[25][25];
int N;
int s1[25];
int s2[25];
int num=0;
int step[100000];
void init(int n)
{
	int t=0;
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<n;j++)
		{
			a[i][j]=t++;
		}
	}
}
void dfs(int x,int y,int deep)
{
	if(x<0||x>=N||y<0||y>=N||visit[x][y]) return ;
	visit[x][y]=true;
	step[deep]=a[x][y];
	if(x==(N-1)&&y==(N-1)) 
	{
 		if(deep+1==num) 
 		{
 			for(int j=0;j<=deep;j++)
 				cout<<step[j]<<' ';
 		}
/* 		for(int i=0;i<N;i++)
 		{
 			for(int j=0;j<N;j++)
 			if(visit[i][j]) cout<<'1';
 			else cout<<'0';
 			cout<<endl;
 		}
 		cout<<endl;
*/		visit[x][y]=false;
		return ;
	}
	if(y!=N-1&&s1[y+1]&&s2[x])
	{
		s1[y+1]--;
		s2[x]--;
		dfs(x,y+1,deep+1);
		s1[y+1]++;
		s2[x]++;
	}
	if(x!=N-1&&s2[x+1]&&s1[y])
	{
		s2[x+1]--;
		s1[y]--;
		dfs(x+1,y,deep+1);
		s2[x+1]++;
		s1[y]++;
	}
	if(y!=0&&s1[y-1]&&s2[x])
	{
		s1[y-1]--;
		s2[x]--;
		dfs(x,y-1,deep+1);
		s1[y-1]++;
		s2[x]++;
	}
	if(x!=0&&s2[x-1]&&s1[y])
	{
		s2[x-1]--;
		s1[y]--;
		dfs(x-1,y,deep+1);
		s2[x-1]++;
		s1[y]++;
	}
	visit[x][y]=false;
}
int main()
{
	cin>>N;
	init(N);
	for(int i=0;i<N;i++)
		cin>>s1[i];
	for(int i=0;i<N;i++)
		cin>>s2[i];
	num=accumulate(s1,s1+N,0);
	s1[0]--;
	s2[0]--;
	dfs(0,0,0);
	return 0;
} 
