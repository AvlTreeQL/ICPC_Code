/*

随意组合

小明被绑架到X星球的巫师W那里。

其时，W正在玩弄两组数据 (2 3 5 8) 和 (1 4 6 7)
他命令小明从一组数据中分别取数与另一组中的数配对，共配成4对（组中的每个数必被用到）。
小明的配法是：{(8,7),(5,6),(3,4),(2,1)}

巫师凝视片刻，突然说这个配法太棒了！

因为：
每个配对中的数字组成两位数，求平方和，无论正倒，居然相等：
87^2 + 56^2 + 34^2 + 21^2  =  12302
78^2 + 65^2 + 43^2 + 12^2  =  12302

小明想了想说：“这有什么奇怪呢，我们地球人都知道，随便配配也可以啊！”
{(8,6),(5,4),(3,1),(2,7)}

86^2 + 54^2 + 31^2 + 27^2 = 12002
68^2 + 45^2 + 13^2 + 72^2 = 12002

巫师顿时凌乱了。。。。。

请你计算一下，包括上边给出的两种配法，巫师的两组数据一共有多少种配对方案具有该特征。
配对方案计数时，不考虑配对的出现次序。
就是说：
{(8,7),(5,6),(3,4),(2,1)}
与
{(5,6),(8,7),(3,4),(2,1)}
是同一种方案。

注意：需要提交的是一个整数，不要填写任何多余内容（比如，解释说明文字等）
answer:24
*/ 
#include<bits/stdc++.h>
using namespace std;
int a[2],b[2],c[2],d[2];

int main()
{
	int aa[]={2,3,5,8},bb[]={1,4,6,7};
	int ans=0;
	do
	{
		a[0]=aa[0]*10+bb[0];
		a[1]=bb[0]*10+aa[0];
		
		b[0]=aa[1]*10+bb[1];
		b[1]=bb[1]*10+aa[1];
		
		c[0]=aa[2]*10+bb[2];
		c[1]=bb[2]*10+aa[2];
		
		d[0]=aa[3]*10+bb[3];
		d[1]=bb[3]*10+aa[3];
		
		for(int i=0;i<2;i++)
		{
			for(int j=0;j<2;j++)
			{
				for(int k=0;k<2;k++)
				{
					for(int l=0;l<2;l++)
					{
						long long temp1=a[i]*a[i]+b[j]*b[j]+c[k]*c[k]+d[l]*d[l];
						long long temp2=a[!i]*a[!i]+b[!j]*b[!j]+c[!k]*c[!k]+d[!l]*d[!l];
						if(temp1==temp2&&a[i]<a[!i])  
						{
							cout<<a[i]<<' '<<b[j]<<' '<<c[k]<<' '<<d[l]<<' '<<temp1<<endl;
							cout<<a[!i]<<' '<<b[!j]<<' '<<c[!k]<<' '<<d[!l]<<' '<<temp2<<endl<<endl;
							ans++;
						}
					}
				} 
			}
		}
	}while(next_permutation(bb,bb+4));

	cout<<ans<<endl;
	return 0;
} 
